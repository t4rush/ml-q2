# -*- coding: utf-8 -*-
"""Quarter 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JLjS0fdvfZJt41o3534A-Fs7SqjVIivf
"""

import numpy as np
from sklearn.datasets import make_moons, make_circles, make_blobs
from sklearn.cluster import KMeans
from sklearn.metrics.pairwise import rbf_kernel
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score
from sklearn.utils import check_random_state
import matplotlib.pyplot as plt
import time

def generate_spiral_data(n_points, noise=0.1):
    theta = np.sqrt(np.random.rand(n_points)) * 2 * np.pi
    r_a = 2 * theta + np.pi
    data_a = np.array([np.cos(theta) * r_a, np.sin(theta) * r_a]).T
    data_a += np.random.randn(n_points, 2) * noise
    r_b = -2 * theta - np.pi
    data_b = np.array([np.cos(theta) * r_b, np.sin(theta) * r_b]).T
    data_b += np.random.randn(n_points, 2) * noise
    return np.vstack([data_a, data_b]), np.hstack([np.zeros(n_points), np.ones(n_points)])

def nystrom_kernel(X, gamma, n_components, random_state=None):
    random_state = check_random_state(random_state)
    n_samples = X.shape[0]

    indices = random_state.choice(n_samples, n_components, replace=False)
    basis = X[indices]

    K_mm = rbf_kernel(basis, gamma=gamma)
    K_nm = rbf_kernel(X, basis, gamma=gamma)

    W_inv = np.linalg.pinv(K_mm)
    K_approx = K_nm @ W_inv @ K_nm.T

    return K_approx

datasets = {
    'moon': make_moons(200, noise=0.05, random_state=0),
    'spiral': generate_spiral_data(200, noise=0.05),
    'circles': make_circles(n_samples=300, noise=0.05, factor=0.5, random_state=0),
    'blobs': make_blobs(n_samples=300, centers=[[1, 1], [2, 2]], cluster_std=0.25, random_state=0)
}

plt.figure(figsize=(20, len(datasets) * 8))

for idx, (name, (X, y)) in enumerate(datasets.items(), 1):
    print(f"Processing {name} dataset...")

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)

    n_clusters = 2
    start_time_linear = time.time()
    kmeans_linear = KMeans(n_clusters=n_clusters, random_state=42)
    clusters_linear = kmeans_linear.fit_predict(X_scaled)
    end_time_linear = time.time()
    runtime_linear = end_time_linear - start_time_linear
    acc_linear = max(accuracy_score(y, clusters_linear), accuracy_score(y, 1 - clusters_linear))

    n_components = 50
    start_time_nystrom = time.time()
    best_acc_nystrom = -1
    best_gamma_nystrom = None
    best_clusters_nystrom = None

    for gamma in np.arange(0, 7.01, 0.1):
        K_approx = nystrom_kernel(X_scaled, gamma=gamma, n_components=n_components, random_state=42)

        N = K_approx.shape[0]
        one_n = np.ones((N, N)) / N
        K_centered = K_approx - one_n @ K_approx - K_approx @ one_n + one_n @ K_approx @ one_n

        kmeans_nystrom = KMeans(n_clusters=n_clusters, random_state=42)
        clusters_nystrom = kmeans_nystrom.fit_predict(K_centered)

        acc_nystrom = max(accuracy_score(y, clusters_nystrom), accuracy_score(y, 1 - clusters_nystrom))
        if acc_nystrom > best_acc_nystrom:
            best_acc_nystrom = acc_nystrom
            best_gamma_nystrom = gamma
            best_clusters_nystrom = clusters_nystrom

    end_time_nystrom = time.time()
    runtime_nystrom = end_time_nystrom - start_time_nystrom

    start_time_kernel = time.time()
    best_acc_kernel = -1
    best_gamma_kernel = None
    best_clusters_kernel = None

    for gamma in np.arange(0, 7.01, 0.1):
        K = rbf_kernel(X_scaled, gamma=gamma)

        N = K.shape[0]
        one_n = np.ones((N, N)) / N
        K_centered = K - one_n @ K - K @ one_n + one_n @ K @ one_n

        kmeans_kernel = KMeans(n_clusters=n_clusters, random_state=42)
        clusters_kernel = kmeans_kernel.fit_predict(K_centered)

        acc_kernel = max(accuracy_score(y, clusters_kernel), accuracy_score(y, 1 - clusters_kernel))
        if acc_kernel > best_acc_kernel:
            best_acc_kernel = acc_kernel
            best_gamma_kernel = gamma
            best_clusters_kernel = clusters_kernel

    end_time_kernel = time.time()
    runtime_kernel = end_time_kernel - start_time_kernel

    plt.subplot(len(datasets), 3, 3 * idx - 2)
    plt.scatter(X[:, 0], X[:, 1], c=clusters_linear, cmap='viridis', s=50, edgecolor='k')
    plt.title(f"{name} - Linear K-means\nAccuracy: {acc_linear:.2f}\nRuntime: {runtime_linear:.2f}s")
    plt.xlabel("Feature 1")
    plt.ylabel("Feature 2")

    plt.subplot(len(datasets), 3, 3 * idx - 1)
    plt.scatter(X[:, 0], X[:, 1], c=best_clusters_nystrom, cmap='viridis', s=50, edgecolor='k')
    plt.title(f"{name} - Nystr√∂m Kernel K-means\nGamma: {best_gamma_nystrom:.2f}\nAccuracy: {best_acc_nystrom:.2f}\nRuntime: {runtime_nystrom:.2f}s")
    plt.xlabel("Feature 1")
    plt.ylabel("Feature 2")

    plt.subplot(len(datasets), 3, 3 * idx)
    plt.scatter(X[:, 0], X[:, 1], c=best_clusters_kernel, cmap='viridis', s=50, edgecolor='k')
    plt.title(f"{name} - Full Kernel K-means\nGamma: {best_gamma_kernel:.2f}\nAccuracy: {best_acc_kernel:.2f}\nRuntime: {runtime_kernel:.2f}s")
    plt.xlabel("Feature 1")
    plt.ylabel("Feature 2")

plt.tight_layout()
plt.show()